clear;

fd = 10e6;                % Частота дискретизации
Td = 1/fd;                % Интервал дискретизации

T = 1e-3;                 % Длительность анализируемой выборки сигнала
Nd = fix(T/Td);           % Количество отсчётов
 
fi = 1e6;                 % Частота сигнала

t = Td*(0:Nd-1);          % Массив, содержащий моменты времени [0  1*Td  2*Td ... ]

phi = 2*pi*rand(1, 1);     % Случайная начальная фаза сигнала
s = cos(2*pi*t*fi); % несущее колебание

TPSP = 1e-3;  % Период дальномерного кода
PNSize = 511;  % Количество символов дальномерного кода на 1 период
PN = sign(randn(1,511)); % Дальномерный код

Tpn = TPSP/PNSize; % Длительность одного символа ПСП
Ind = mod(fix(t/Tpn),PNSize)+1; % Массив индексов
PSP = PN(Ind); % Растянутая последовательность    

% Вот здесь ошибка с перемножением матриц
%   U = PSP*(cos(2*pi*fi*t)); % Модулированный сигнал
% PSP - матрица размером 1*10000, t - матрица размером 1*10000. Оператор "*" - матричное произведение.
% Но матрицы можно перемножать только если у них согласованный размер - количество столбцов в первой должно быть равно
% числу строк во второй, что в данном случае не так.
% В этой программе нужно использовать поэлементное перемножение ".*":
U = PSP .* (cos(2*pi*fi*t)); % Модулированный сигнал

A = 1; % Амплитуда 

Y = abs(fft(U));  % Cпектр
Y = fftshift(Y);
F = fd/2*((0:Nd-1)-Nd/2)/(Nd/2); % Частота
plot(F/1e6, 20*log10(Y/max(Y)));


figure(1);
xlim([-5 +5])

% Данный масштаб не подходит в рассматриваемом примере. Можно просто дать Matlab автоматически выбрать масштаб
% ylim(A*[-1.1 1.1])

grid on
xlabel('Frequency, MHz')    
ylabel('S, dB')







